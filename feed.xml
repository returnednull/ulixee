<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Ulixee Blog</title>
        <link>https://ulixee.org/</link>
        <description>A blog about scraping, features and experiences developing Ulixee</description>
        <lastBuildDate>Tue, 24 Aug 2021 14:25:54 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Gridsome Feed Plugin</generator>
        <atom:link href="https://ulixee.org/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Moving from Chromium to Chrome]]></title>
            <link>https://ulixee.org/blog/chromium-chrome</link>
            <guid>https://ulixee.org/blog/chromium-chrome</guid>
            <pubDate>Fri, 19 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
We're moving our underlying engine from Chromium to Chrome in the coming weeks. 

## Why?
There are a few reasons we decided to go this direction:
1. Chrome is the actual browser being used in the wild by consumers.
2. Chrome has increasingly diverged from Chromium. In our DoubleAgent testing, we're seeing Chrome 85-89 steadily diverge features. This makes it harder and harder to emulate Chrome when using Chromium as the engine.
3. Chrome has certain features that aren't in Chromium that will be nearly impossible to emulate (x-headers to Google sites, Widevine, etc). In theory, you could use DRM as a way to weed out Chromium users masking themselves as Chrome users.

## Chrome Version-Specific Installers 
This switch was somewhat challenging, primarily because the Chrome team doesn't openly publish versions of Chrome that stay on the version you want them on. Even on Ubuntu, if you install the .deb release, it will install an apt updater, and if you're not careful, your engine will swap out underneath you.

Our first task was to go out and find stable Chrome installations for each version. We created a new project called [chrome-versions](https://github.com/ulixee/chrome-versions) that downloads, extracts, and stores versions of Chrome for Linux, Windows and Mac. 

For each version, we stripped out the auto-update features and converted them to .tar archives that can be extracted side-by-side. They're then published on Github as release assets for each Chrome version (eg, https://github.com/ulixee/chrome-versions/releases/tag/88.0.4324.182)

On Debian/Ubuntu, Chrome often needs packages to be installed. We re-bundled the .deb control file into a new installer that can be run after you extract the chrome executable - this makes setting up CI or docker very simple for 1 or more Chrome installations.

## Ulixee Hero
Hero has been updated to use Chrome everywhere. Our emulators have "polyfills" auto-generated for how to resemble Chrome headed when running each version headless. The changes are significant enough from Chromium that you need to actually use Chrome underneath. 

No changes should be visible in your scripts, but you might see some installation changes as you go to upgrade. We also experienced some changes in no-sandbox features when running on Docker. Your mileage here may vary. 

This new release will have an updated Dockerfile and files under `tools/docker/*` showing how to get up and running on Docker-slim.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Scaling Hero Scrapes with Handlers]]></title>
            <link>https://ulixee.org/blog/handling-scale</link>
            <guid>https://ulixee.org/blog/handling-scale</guid>
            <pubDate>Tue, 29 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
When you start using Hero, you often copy and paste the default examples. As we started to use Hero on larger extraction efforts, it became clear that we didn't have a clear story for "how" you go from that starting example to running 2, or even 1000 scrapes.

As you start to think about structuring a bigger effort, a bunch of questions come up:

- Do you create a new Hero instance every time? Or do you simply add tabs?
- How expensive is it to create many instances?
- How should I make sure not to overload the host machine with the number of scrapes running at the same time?
- How do I add new machines when I max out the current one?

As we explored simplifying this story, we wanted to make the progression of "examples" through to full-scrapes a smooth process. Something like this:

#### Step 1: Try Out an Example

Trying out examples should require as little setup as possible, so we added a new `default export` that's a ready-to-go client for Hero.

```js
import hero from `@ulixee/hero`;

(async () => {
  // no initilization required!
  await hero.goto('https://ulixee.org');
  const datasetLinks = await hero.document.querySelectorAll('a.DatasetSummary');
  for (const link of datasetLinks) {
    const name = await link.querySelector('.title').textContent;
    const href = await link.getAttribute('href');
    const dataset = { name, href };
    console.log('Ulixee Dataset', dataset);
  }

  await hero.close();
})();
```

#### Step 2: Run Multiple Scrapes

Hero instances are lightweight, but what do you do when you need to queue up thousands of them to run. Until now, you've been on your own to use libraries like `p-queue`, keeping track of promises, or simply waiting and looping.

We introduced a new idea into Hero called a [`Handler`](/docs/basic-interfaces/handler) to help run multiple scrapes in one session. Handlers manage the concurrency of multiple scrapes to ensure your machine doesn't get overloaded and hang. We designed it so your code should require almost no changes to transition to many scrapes.

```js
import { Handler } from `@ulixee/hero`;

(async () => {
  const handler = new Handler({ maxConcurrency: 5 });

  handler.dispatchHero(async hero => {
    // hero is automatically created for us
    await hero.goto('https://ulixee.org');
    const datasetLinks = await hero.document.querySelectorAll('a.DatasetSummary');
    for (const link of datasetLinks) {
      const name = await link.querySelector('.title').textContent;
      const href = await link.getAttribute('href');
      const dataset = { name, href };

      // add a name to each hero so we can find each scrape on Replay
      const heroOptions = { name };
      handler.dispatchHero(getDatasetCost, dataset, heroOptions);
    }
  });

  // only 5 heros will be active at a given time until all are done
  await handler.waitForAllDispatches();
  await handler.close();
})();

// my data gets passed in once an hero is available
async function getDatasetCost(hero, dataset) {
  let { name, href } = dataset;
  if (!href.startsWith('http')) href = `https://ulixee.org${href}`;
  console.log(href);
  await hero.goto(href);
  await hero.waitForPaintingStable();
  const cost = await hero.document.querySelector('.cost .large-text').textContent;
  console.log('Cost of %s is %s', dataset.name, cost);
}
```

#### Step 3: Add Scraping Machines

You might find that you need to increase the speed of your scrapes. So the next transition you'll likely want to make is to add remote machines. Handlers are built to round-robin between multiple [`ConnectionToCore`](/docs/advanced/connection-to-core) instances.

```js
import { Handler } from `@ulixee/hero`;

(async () => {
  const handler = new Handler(
    {
      maxConcurrency: 5,
      host: '192.168.1.1:2300', // fictional remote hero #1
    },
    {
      maxConcurrency: 5,
      host: '192.168.1.2:2300', // fictional remote hero #2
    },
  );
  
// ... everything else is the same!

  handler.dispatchHero(async hero => {
    // hero is automatically created for us
    await hero.goto('https://ulixee.org');
    ...
```


#### Default Exports

To get to this setup, you'll notice some changes in the default exports when you install Hero 1.3.0-alpha.1. The default exports that come out of the `@ulixee/hero` package is now a pre-initialized instance of the `Hero` class.

[`Handler`](/docs/basic-interfaces/handler) and [`Hero`](/docs/basic-interfaces/hero) are available as exports from `@ulixee/hero` if you'd like to continue to use those. To customize a "Remote" `Hero` for an [`Hero`](/docs/basic-interfaces/hero), you can create a new instance with a [`connectionToCore`](/docs/basic-interfaces/hero#constructor) parameter, or use the [`.configure()`](/docs/basic-interfaces/hero#configure) function.


#### That's it!

That's our change. We hope it leads to a very simple model to understand how to scale up your Hero instances. Feedback is welcome as always on any of our channels (listed in header)!
]]></content:encoded>
        </item>
    </channel>
</rss>